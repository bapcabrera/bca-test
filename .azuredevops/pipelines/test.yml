parameters:
# Source parameters
- name: psName
  displayName: PowerShell Name
  type: string
  default: 'Bca.Test'
- name: psType
  type: string
  displayName: PowerShell Type
  default: 'Module'
  values:
    - Module
    - Script
- name: sourceDirectory
  displayName: Source Directory
  type: string
  default: $(Build.Repository.LocalPath)/src/Bca.Test

# NuGet Package parameters
- name: nugetName
  displayName: NuGet Package Name
  type: string
  default: Bca.Test
- name: nugetFeed
  displayName: NuGet Feed Name
  type: string
  default: bca
- name: nugetPush
  displayName: Push NuGet Package
  type: boolean
  default: true

# Chocolatey Package parameters
- name: chocoName
  displayName: Chocolatey Package Name
  type: string
  default: bca-test
- name: chocoFeed
  displayName: Chocolatey Feed Name
  type: string
  default: bca-choco
- name: chocoPush
  displayName: Push Chocolatey Package
  type: boolean
  default: true

# Tests parameters
- name: runAnalyzer
  displayName: Run PSScriptAnalyzer
  type: boolean
  default: true
- name: testWindows
  displayName: Test on Windows
  type: boolean
  default: true
- name: testLinux
  displayName: Test on Linux
  type: boolean
  default: true
- name: testMacOs
  displayName: Test on MacOS
  type: boolean
  default: true
- name: coveragePath
  displayName: Code Coverage Path (relative to Source Directory)
  type: string
  default: 'Public/*'
- name: excludeTags
  displayName: Test Tags to Exclude (one per line)
  type: object
  default: null

trigger:
- none

variables:
- name: poolName
  value: 'Azure Pipelines'
- name: vmImageWindows
  value: 'windows-latest'
- name: vmImageLinux
  value: 'ubuntu-latest'
- name: vmImageMacOS
  value: 'macOS-latest'

# Initialization stage will retrieve the version and check if packages already exist for this version
stages: 
- stage: Initialization
  displayName: Build Initialization
  pool:
    name: ${{ variables.poolName }}
    vmImage: ${{ variables.vmImageWindows }}
  jobs:
  - job: Initialization
    displayName: Initialize Build
    steps:
    - powershell: |
        $Prerelease = $false
        switch ('${{ parameters.psType }}')
        {
          'Module'
          {
            $PSData = Import-PowerShellDataFile ./${{ parameters.psName }}.psd1
            $Version = "{0}{1}" -f $PSData.ModuleVersion.ToString(), $PSData.PrivateData.PSData.Prerelease
            if ($PSData.PrivateData.PSData.Prerelease) { $Prerelease = $true }
          }
          'Script'
          {
            $Version = (Test-ScriptFileInfo ./${{ parameters.psName }}.ps1).Version.ToString()
            if ($Version.Split("-")[1]) { $Prerelease = $true }
          }
        }
        Write-Host "${{ parameters.psType }} ${{ parameters.psName }} version is $Version"
        Write-Host "##vso[task.setvariable variable=packageVersion;isOutput=true]$($Version)"
        Write-Host "${{ parameters.psType }} ${{ parameters.psName }} version is prerelease = $Prerelease"
        Write-Host "##vso[task.setvariable variable=isPrerelease;isOutput=true]$($Prerelease)"
      name: getVersion
      workingDirectory: ${{ parameters.sourceDirectory }}
      displayName: 'Get ${{ parameters.psType }} Version'
    - ${{ if eq(parameters.nugetPush, true) }}:
      - task: DownloadPackage@1
        displayName: Download NuGet Package '${{ parameters.nugetName }}'
        inputs:
          packageType: nuget
          feed: ${{ parameters.nugetFeed }}
          definition: ${{ parameters.nugetName }}
          version: $(getVersion.packageVersion)
          extract: false
          downloadPath: $(Pipeline.Workspace)
      - powershell : |
          if ((Test-Path (Join-Path "$(Pipeline.Workspace)" "${{ parameters.nugetName }}.nupkg")))
          {
              Write-Error -Message "Package '${{ parameters.nugetName }}' with version $(getVersion.packageVersion) already exists." -Category ResourceExists -CategoryActivity "Test-Package" -TargetType "nuget" -TargetName "${{ parameters.nugetName }}" -Exception ResourceExistsException
          }
        displayName: Check NuGet Package '${{ parameters.nugetName }}'
    - ${{ if eq(parameters.chocoPush, true) }}:
      - task: DownloadPackage@1
        displayName: Download Chocolatey Package '${{ parameters.chocoName }}'
        inputs:
          packageType: nuget
          feed: ${{ parameters.chocoFeed }}
          definition: ${{ parameters.chocoName }}
          version: $(getVersion.packageVersion)
          extract: false
          downloadPath: $(Pipeline.Workspace)
      - powershell : |
          if ((Test-Path (Join-Path "$(Pipeline.Workspace)" "${{ parameters.chocoName }}.nupkg")))
          {
              Write-Error -Message "Package '${{ parameters.chocoName }}' with version $(getVersion.packageVersion) already exists." -Category ResourceExists -CategoryActivity "Test-Package" -TargetType "nuget" -TargetName "${{ parameters.chocoName }}" -Exception ResourceExistsException
          }
        displayName: Check Chocolatey Package '${{ parameters.chocoName }}'
    - powershell: Write-Host "##vso[build.updatebuildnumber]${{ parameters.psName }}-$(getVersion.packageVersion)-$(Build.BuildNumber)"
      displayName: Set Build Number
    - powershell: |
        Write-Host ${{ parameters.excludeTags }}
        $Tags = "${{ parameters.excludeTags }}"
        $Tags | gm
        $Tags | ForEach-Object {
          Write-Host "----"
          Write-Host $_
        }


# Test stage will run Pester tests and code coverage
- stage: Test
  displayName: Test ${{ parameters.psType }}
  dependsOn: Initialization
  variables:
    version: $[ stageDependencies.Initialization.Initialization.outputs['getVersion.packageVersion'] ]
    isPrerelease: $[ stageDependencies.Initialization.Initialization.outputs['getVersion.isPrerelease'] ]
  jobs:
  - job: Test
    displayName: Test on
    strategy:
      matrix:
        Windows:
          poolName: ${{ variables.poolName }}
          vmImage: ${{ variables.vmImageWindows }}
        Linux:
          poolName: ${{ variables.poolName }}
          vmImage: ${{ variables.vmImageLinux }}
        MacOS:
          poolName: ${{ variables.poolName }}
          vmImage: ${{ variables.vmImageMacOS }}
    pool:
      name: $(poolName)
      vmImage: $(vmImage)
    steps:
    - powershell: |
        Find-Module PSScriptAnalyzer | Install-Module -Scope CurrentUser -Force
        Invoke-ScriptAnalyzer -Path ./ -Settings PSGallery -Recurse -Severity Error -ReportSummary -EnableExit
      displayName: 'Run PowerShell Script Analyzer'
      workingDirectory: '${{ parameters.sourceDirectory }}'
      condition: |
        and(
          succeeded(),
          eq('${{ parameters.runAnalyzer }}', true),
          or(
            and(eq(variables['Agent.OS'], 'Windows_NT'), eq('${{ parameters.testWindows }}', true)),
            and(eq(variables['Agent.OS'], 'Linux'), eq('${{ parameters.testLinux }}', true)),
            and(eq(variables['Agent.OS'], 'Darwin'), eq('${{ parameters.testMacOS }}', true))
          )
        )
    - powershell: |
        Write-Host "Installing ${{ parameters.psType }} dependencies..."
        switch ('${{ parameters.psType }}')
        {
          'Module'
          {
            (Import-PowerShellDataFile ./${{ parameters.psName }}.psd1).RequiredModules | Where-Object { $_ } | ForEach-Object {
                Write-Host " - Installing module '$($_.ModuleName)' with version '$($_.ModuleVersion)'."
                Find-Module -Name $_.ModuleName -RequiredVersion $_.ModuleVersion -AllowPrerelease | Install-Module -Scope CurrentUser -Force
            }
          }
          'Script'
          {
            $ScriptFileInfo = Test-ScriptFileInfo ./${{ parameters.psName }}.ps1
            $ScriptFileInfo.RequiredModules | Where-Object { $_ } | ForEach-Object {
                Write-Host " - Installing module '$($_.ModuleName)' with version '$($_.ModuleVersion)'."
                Find-Module -Name $_.ModuleName -RequiredVersion $_.ModuleVersion -AllowPrerelease | Install-Module -Scope CurrentUser -Force
            }
            $ScriptFileInfo.RequiredScripts | Where-Object { $_ } | ForEach-Object {
                Write-Host " - Installing script '$($_)'."
                Find-Script -Name $_ -AllowPrerelease | Install-Script -Scope CurrentUser -Force
            }
          }
        }
      workingDirectory: '${{ parameters.sourceDirectory }}'
      displayName: 'Install ${{ parameters.psType }} Dependencies'
      condition: |
        and(
          succeeded(),
          or(
            and(eq(variables['Agent.OS'], 'Windows_NT'), eq('${{ parameters.testWindows }}', true)),
            and(eq(variables['Agent.OS'], 'Linux'), eq('${{ parameters.testLinux }}', true)),
            and(eq(variables['Agent.OS'], 'Darwin'), eq('${{ parameters.testMacOS }}', true))
          )
        )
    - powershell: |
        Find-Module Pester | Install-Module -Scope CurrentUser -Force
        
        $ExcludeTags = "".Split(",")
        $CodeCoverageResult = '$(Agent.TempDirectory)/${{ parameters.psName }}.$(version).$(Agent.OS).Coverage.xml'
        $TestResult = '$(Agent.TempDirectory)/${{ parameters.psName }}.$(version).$(Agent.OS).Tests.xml'

        $CodeCoverage = "./${{ parameters.coveragePath }}"
        #switch ('${{ parameters.psType }}')
        #{
        #  'Module' { $CodeCoverage = "./Public/*" }
        #  'Script' { $CodeCoverage = "./*" }
        #}
        $Pester = Invoke-Pester -Path ./ -CodeCoverage $CodeCoverage -CodeCoverageOutputFile $CodeCoverageResult -OutputFile $TestResult -OutputFormat NUnitXml -ExcludeTagFilter $ExcludeTags -PassThru -Strict
        #switch ('$(Agent.OS)')
        #{
        #  'Windows_NT' { $Pester = Invoke-Pester -Path ./ -CodeCoverage $CodeCoverage -CodeCoverageOutputFile $CodeCoverageResult -OutputFile $TestResult -OutputFormat NUnitXml -PassThru -Strict }
        #  default { $Pester = Invoke-Pester -Path ./ -OutputFile $TestResult -OutputFormat NUnitXml -ExcludeTagFilter WindowsOnly -PassThru -Strict }
        #}

        $Pester.Tests | ForEach-Object {
          switch ($_.Result)
          {
            "Passed" { $Status = "section" }
            "Failed" { $Status = "error" }
            default { $Status = "warning" }
          }
          Write-Host ("##[{0}] [{1}] {2} ({3})" -f $Status, $_.Result, ($_.Path -join ' > '), $_.Duration)
        }
      displayName: 'Run Pester Tests and Coverage'
      workingDirectory: '${{ parameters.sourceDirectory }}'
      condition: |
        and(
          succeeded(),
          or(
            and(eq(variables['Agent.OS'], 'Windows_NT'), eq('${{ parameters.testWindows }}', true)),
            and(eq(variables['Agent.OS'], 'Linux'), eq('${{ parameters.testLinux }}', true)),
            and(eq(variables['Agent.OS'], 'Darwin'), eq('${{ parameters.testMacOS }}', true))
          )
        )
    - task: PublishTestResults@2
      displayName: 'Publish Test Results'
      inputs:
        testResultsFormat: NUnit
        testResultsFiles: '**/${{ parameters.psName }}.$(version).$(Agent.OS).Tests.xml'
        searchFolder: $(Agent.TempDirectory)
        mergeTestResults: true
        failTaskOnFailedTests: true
        testRunTitle: 'Tests on $(Agent.OS) for ${{ parameters.psName }} ($(version))'
      condition: |
        and(
          succeeded(),
          or(
            and(eq(variables['Agent.OS'], 'Windows_NT'), eq('${{ parameters.testWindows }}', true)),
            and(eq(variables['Agent.OS'], 'Linux'), eq('${{ parameters.testLinux }}', true)),
            and(eq(variables['Agent.OS'], 'Darwin'), eq('${{ parameters.testMacOS }}', true))
          )
        )
    - task: PublishCodeCoverageResults@1
      displayName: 'Publish Code Coverage'
      inputs:
        codeCoverageTool: 'JaCoCo'
        summaryFileLocation: '$(Agent.TempDirectory)/${{ parameters.psName }}.$(version).$(Agent.OS).Coverage.xml'
        reportDirectory: '$(Agent.TempDirectory)/$(Agent.OS)'
        pathToSources: "${{ parameters.sourceDirectory }}/Public/"
      condition: |
        and(
          succeeded(),
          or(
            and(eq(variables['Agent.OS'], 'Windows_NT'), eq('${{ parameters.testWindows }}', true)),
            and(eq(variables['Agent.OS'], 'Linux'), eq('${{ parameters.testLinux }}', true)),
            and(eq(variables['Agent.OS'], 'Darwin'), eq('${{ parameters.testMacOS }}', true))
          )
        )
#    - powershell: Write-Host "$(Agent.OS)"
#      condition: |
#        and(
#          succeeded(),
#          or(
#            and(eq(variables['Agent.OS'], 'Windows_NT'), eq('${{ parameters.testWindows }}', true)),
#            and(eq(variables['Agent.OS'], 'Linux'), eq('${{ parameters.testLinux }}', true)),
#            and(eq(variables['Agent.OS'], 'Darwin'), eq('${{ parameters.testMacOS }}', true))
#          )
#        )